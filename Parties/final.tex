\subsubsection{Prise en compte des capteurs}

Comme mentionné précédemment, notre système réel comporte des capteurs pour mesurer la vitesse de rotation de la MCC. En particulier, nous disposons de deux types de capteurs de vitesse différents : une dynamo-tachymétrique et un codeur incrémental. Nous considérons que leurs constantes de temps sont largement plus rapides que celles de notre système et les modéliserons donc seulement par des gains. Pour la dynamo-tachymétrique, son gain est spécifié comme étant de 6 V pour 1000 tr/min. Nous veillerons à diviser ce gain par deux pour faire en sorte que la tension de commande reste inférieur à 15 V. \\

Finalement, dans notre modèle Matlab, la vitesse de sortie est en $rad/s$, on multiplie donc cette vitesse par $\frac{30}{\pi}$ pour la convertir en tr/min. Le gain final à appliquer sur Matlab pour la dynamo-tachymétrique est donc  : $$k=\dfrac{1}{2}\cdot \dfrac{6}{1000}\cdot\dfrac{30}{\pi}\approx 28\cdot 10^{-3} $$

Sur PSIM, le capteur nous retourne déjà une vitesse en $tr/min$, il suffira donc d'appliquer le gain de $\frac{3}{1000}$. Les modifications apportées sont présentées ci-dessous:
\begin{figure}[H]
    \centering
    \subfloat[\centering Sur Matlab]{{\includegraphics[width=9cm]{Images/Modelisation/MATLAB/NV_Gain_Matlab.jpg} }}%
    \qquad
    \subfloat[\centering Sur PSIM]{{\includegraphics[width=6cm]{Images/Modelisation/PSIM/NV_Gain_PSIM.jpg}}}%
    \caption{Modifications prenant en compte les capteurs \hyperref[sec:arb]{*}}
    \label{fig:42}
\end{figure}
Pour le codeur incrémental, nous ferons en sorte qu'il ait un gain identique à la  dynamo-tachymétrique pour n'avoir qu'à dimensionner qu'un seul correcteur. \\ \\
Après calcul des nouveaux correcteurs  grâce au \textit{PID Tuner}, nous obtenons les valeurs suivantes: $$C(p)=P\Big(1+I\dfrac{1}{p}\Big)~\text{avec}~P=2.27~\text{et}~I=22.8~s^{-1}$$
Comme précédemment, nous avons vérifié ce correcteur et obtenu des résultats concluants. Cependant, nous allons cette fois-ci mettre en avant une comparaison complète de notre système. Pour cela nous simulerons le système complet et corrigé (courant et vitesse) sur PSIM, ainsi que le système complet et corrigé \textbf{sans les hypothèses simplificatrices} sur Matlab. C'est-à-dire que nous garderons tous les éléments de notre schéma-bloc hormis les éléments évoqués dans la partie préliminaire à l'asservissement.
\newpage
Nous avons  ainsi le schéma Simulink suivant:
\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{Images//Modelisation/MATLAB/Matlab_complet.jpg}
    \caption{Schéma-bloc de l'asservissement avec capteurs \hyperref[sec:arb]{*} }
    \label{fig:43}
\end{figure}
Où $G$ et $H_0$ sont les fonctions de transfert permettant d'obtenir respectivement le courant (ou sa tension image considérant un gain unitaire) à partir de la commande issue des correcteurs et la tension image de la vitesse à partir du courant moteur.
Le schéma utilisé pour PSIM est le même que celui utilisé pour la vérification de l'asservissement de vitesse, ce dernier faisant déjà intervenir tous les éléments.


Nous retrouverons sur les figures suivantes le modèle avec le hacheur de PSIM en rouge et le modèle Matlab en bleu.
\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\linewidth]{Images/Modelisation/MATLAB/Comp_syst_complet_asservi_vitesse.png}
    \caption{Vérification de l'asservissement avec capteur (vitesse) \hyperref[sec:arb]{*} }
    \label{fig:44}
\end{figure}
\textit{On a en abscisse le temps en seconde et en ordonnée l'image de la vitesse en volt}.
\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\linewidth]{Images/Modelisation/MATLAB/Comp_syst_complet_asservi_courant.png}
    \caption{ Vérification de l’asservissement avec capteur (courant) \hyperref[sec:arb]{*} }
    \label{fig:45}
\end{figure}
\textit{On a en abscisse le temps en seconde et en ordonnée le courant en ampère (ou son image en volt).}
\\

On observe une concordance parfaite qui valide complètement notre cos correcteurs finaux.

\subsection{Lien entre valeur de référence et valeur moyenne}
Le but d'un asservissement est de faire tendre une grandeur
caractéristique d'un système vers une valeur de référence (une consigne). Cependant, nous avons vu dans les études précédentes que les grandeurs que nous avons à asservir présentent des ondulations plus ou moins importantes. Il est donc légitime de se questionner sur le sens physique de la valeur de référence, étant donné que, la sortie n'étant pas constante, il est  théoriquement impossible pour le système d'atteindre cette valeur. Dans notre cas, en considérant le fait que nous avons un intégrateur dans nos correcteurs, nous allons montrer que les valeurs de références $\Omega_{ref}$ et $I_{Mref}$ sont égales aux valeurs moyennes $<\Omega>$ et $<i_M>$. Cela implique que c'est la valeur moyenne en sortie de notre système que nous allons asservir. La valeur de référence fixera la valeur moyenne de sortie du système.
Nous allons démontrer cela pour le courant, et le cas de la vitesse sera purement analogue. \\ \\
Soit $y$ la variable d'état supplémentaire dûe à la présence d'un intégrateur dans notre système. On sait que: $$y(t)=y(t_0)+\int_{t_0}^t(I_{Mref}-i_M)dt$$
Où $t_0$ est l'instant initial, c'est-à-dire le moment auquel nous avons mis en route le système.\\\\
Si l'on se place en régime permanent, on peut représenter la variation de courant comme suit:
\begin{figure}[H]
    \centering
    \input{CircuitTikz/ref_mean_graph}
    \caption{Signaux liés au codeur incrémental}
\end{figure}

Où $T$ représente une période de MLI du hacheur et $\alpha$ son rapport cyclique.\\ \\
On peut en déduire que $i_M\bigl( ( k+1)T\bigl)=i_M\bigl(kT\bigl)$. De plus, on a : $$
    \left\{
    \begin{array}{*3{>{\displaystyle}c}p{5cm}}
        y\bigl(( k+1)T\bigl)=y(t_0)+\int_{t_0}^{ (k+1)T}(I_{Mref}-i_M)dt \\
        y\bigl(kT\bigl)=y(t_0)+\int_{t_0}^{ kT}(I_{Mref}-i_M)dt
    \end{array}
    \right.
$$
Ainsi: $$y\bigl(( k+1)T\bigl)- y\bigl(kT\bigl)=\int_{kT}^{ (k+1)T}(I_{Mref}-i_M)dt)=T\cdot I_{Mref}-\int_{kT}^{ (k+1)T}i_Mdt=0$$
Il est donc enfin possible d'obtenir le résultat final:
$$T\cdot I_{Mref}-\int_{kT}^{ (k+1)T}i_Mdt=0\Leftrightarrow I_{Mref}=\frac{1}{T}\int_{kT}^{ (k+1)T}i_Mdt=~<i_M>$$
\section{Conception et dimensionnement des circuits électroniques}
Maintenant que nous avons correctement dimensionné nos correcteurs, il est temps de concevoir le système électronique qui permettra de réaliser l'asservissement de manière effective. Pour cela, il faudra dimensionner les circuits relatifs à l'asservissement ainsi que certains circuits annexes primordiaux au bon fonctionnement de l'ensemble du système et au respect du cahier des charges. Il sera important de prendre en compte la tension d'alimentation de la carte qui sera une alimentation \textbf{symétrique +15 -15 V}.
\subsection{Asservissement}
Dans cette partie, nous nous concentrons sur les circuits propres à l'asservissement.

\subsubsection{Comparateur}

Dans notre montage, nous aurons à plusieurs reprises besoin d'un comparateur. Ce composant a pour rôle, comme son nom l'indique, de comparer deux signaux d'entrées. La plupart du temps, un comparateur est un soustracteur, bien qu'il puisse également être un additionneur.
Dans notre cas, nous utiliserons un soustracteur, dont le schéma est le suivant :
\\
\begin{figure}[H]
    \centering
    \input{CircuitTikz/comparateur}
    \caption{Circuit comparateur}
\end{figure}
\newpage
De ce schéma, nous pouvons ensuite calculer la fonction de transfert suivante en supposant l'AOP parfait:

$$
    V_- = \frac{\frac{V_1}{R}+\frac{V_s}{R}}{\frac{1}{R}+\frac{1}{R}}=\frac{V_1+V_s}{2}$$
$$V_+=\frac{1}{2}V_2$$
$$V_+=V_- \Leftrightarrow V_2=V_1+V_s\Leftrightarrow V_s=V_2-V_1 $$

Nous obtenons bien l'équation de comparaison souhaitée. Pour réaliser ce circuit, il suffit donc d'avoir un AOP et 4 résistances de même valeur.
\subsubsection{Correcteur de vitesse}

Nous devons asservir deux composantes de notre système : la vitesse de la MCC et le courant d'induit. Pour cela, nous utiliserons un correcteur de type PI (Proportionnel Intégral) qui permettra de contrôler le régime transitoire mais aussi d'annuler l'erreur statique. Ce correcteur se construit à partir d'un circuit intégrateur en série avec un amplificateur.
\begin{figure}[H]
    \centering
    \input{CircuitTikz/correcteur}
    \caption{Circuit correcteur PI}
\end{figure}

De ce schéma, on déduit la fonction de transfert suivante :



\begin{equation}
    \begin{aligned}
        V                 & = -V_e \cdot \frac{R + \frac{1}{jC\omega}}{R} = -V_e \cdot \frac{1 + jRC\omega}{jRC\omega}                        \\
        V_s               & = -V_ \cdot \frac{R_2}{R_1} = V_e \cdot \frac{R_2}{R_1} \frac{1 + jRC\omega}{jRC\omega}                           \\
        \text{si } \, p   & = j\omega \quad \implies \quad C(p) = \frac{V_s}{V_e} = \frac{R_2}{R_1} \frac{1 + RCp}{RCp} = P(1+\frac{1}{T_ip}) \\
        \text{avec} \quad & \begin{cases}
                                T_i = RC \\
                                K = \frac{R_2}{R_1}
                            \end{cases}
    \end{aligned}
    \label{eq:placeholder_label}
\end{equation}

Il faut à présent choisir les valeurs de composants pour obtenir les coefficients K et $T_i$ calculés précédemment.
Pour rappel, pour l'asservissement de vitesse, nous avions :
$$P = 2,27$$
$$T_i = 0,044$$

Grâce aux relations décrites plus haut, nous pouvons calculer les valeurs de résistances et condensateurs nécessaires.
\newpage
Les calculs effectués sont les suivants : \\
\[K_{vi}=2,27 \Longrightarrow R_1=1200~\Omega \textbf{ et }R_2=2700 ~ \Omega \Longrightarrow K_{vi_{réel}} = \frac{2700}{1200} = 2,25\]
\[T_{iv}=0,044~ s \Longrightarrow R=43~k\Omega \textbf{ et } C=1\cdot10^{-6}~F \Longrightarrow T_{vi_{réel}} = 43000\times1,10^{-6} \approx 0,043~ s\]




\subsubsection{Correcteur de courant}

Le circuit de correction du courant est le même que pour l'asservissement de vitesse, la seule différence est la valeur des composants. On rappelle que pour l'asservissement de courant, on a les valeurs suivantes :
$$P = 6,219$$
$$T_i = 0,00015$$

Les valeurs des correcteurs sont donc calculées ainsi : \\
\[K_{ci}=6,219<1 \Longrightarrow R_1=1100~\Omega \textbf{ et }R_2=6800~ \Omega \Longrightarrow K_{ci_{réel}} = \frac{6800}{1100} = 6,182\]
\[T_{ci}=0,00015~ s \Longrightarrow R_8=1500~\Omega \textbf{ et } C=100,10^{-9}~ F \Longrightarrow T_{ci_{réel}} = 1500\times100\cdot10^{-9} \approx 0,00015~s\]
\subsection{Circuit de mise en forme du signal tachymétrique}
La dynamo tachymétrique ayant un gain de 6 V pour 1000 tr/min, si la consigne appliquée était trop élevée, nous dépasserions la limite maximale supportée par le hacheur qui est de 15 V. Pour remédier simplement à ça, nous avons rajouter un pont diviseur de tension par 2 avec 2 résistances identiques suivi par un AOP en suiveur en sortie de la dynamo tachymétrique.

\subsection{Circuit de mise en forme du signal du codeur incrémental}
Avant de discuter de la solution finale adoptée pour la mise en forme du signal du codeur incrémental, étudions d'abord son fonctionnement.
\\

Le codeur incrémental est un disque comportant 2 pistes : une piste extérieure et une piste intérieure. La piste extérieure est une série de fenêtres réparties équitablement autour du disque : ici on a un codeur incrémental avec 1800 fenêtres donc elles sont chacune décalées d'un angle de $\frac{2\pi}{1800}$. En pratique, une LED vient éclairer le disque en continu d'un côté et de l'autre, un photo-transistor va être éclairé à intervalle régulier. Une illustration du principe est présentée ci-dessous:
\begin{figure}[H]
    \centering
    \input{CircuitTikz/schema_codeur}
    \caption{Principe de fonctionnement du codeur incrémental}
\end{figure}


La fréquence à laquelle le transistor va être éclairé va être directement proportionnelle à la vitesse du moteur. Le photo-transistor va être alternativement saturé et bloqué et va donc fournir un signal carré à sa sortie, nommé $A$.
\newpage
La période de ce signal est ainsi : $$T=\frac{1}{1800}\cdot\frac{2\pi}{\Omega}$$ La piste intérieure est la même que la piste extérieure mais décalée d'un quart de l'angle entre deux fenêtres c'est-à-dire $\frac{1}{4}\cdot \frac{2\pi}{1800}$. Le signal représentant la variation de lumière à travers cette piste sera nommé $B$.\\
Pour mettre en forme ces signaux et récupérer la vitesse du moteur, deux méthodes sont possibles. Ces deux méthodes exploitent la génération d'un signal particulier à partir du signal du codeur pour récupérer l'information de la vitesse. Sur la figure suivante sont présentés les formes d'onde du codeur ainsi que les signaux des deux méthodes permettant la récupération de l'information utile.
\begin{figure}[H]
    \centering
    \input{CircuitTikz/codeur_incr}
    \caption{Signaux liés au codeur incrémental}
\end{figure}
\textit{Pour s'assurer de la bonne qualité des signaux $A$ et $B$ à l'entrée de la carte, nous utiliserons deux comparateurs qui compareront les signaux du codeur avec $\frac{V_{DD}}{2}$. Nous obtiendrons ainsi en sortie des signaux carré de bonne qualité pour leur traitement. }
\\
\begin{itemize}[label=\textbullet]
    \item \textbf{Méthode 1: Circuit monostable }\\
          La première méthode consiste à concevoir un monostable qui produirait une impulsion de largeur $t_0$ fixée à chaque front montant du signal du codeur. Ainsi, on a la relation suivante:
          $$<V_s>=V_{DD}\cdot \dfrac{t_0}{T}=\dfrac{1800\cdot \Omega}{2\pi}\cdot V_{DD}\cdot t_0 = \dfrac{1800\cdot V_{DD}\cdot t_0}{2\pi}\cdot \Omega$$
          On a bien ici une tension directement proportionnelle à la vitesse, il est donc possible de récupérer cette information. Sachant que nous devons obtenir un gain identique à celui de la dynamo tachymétrique, il faut multiplier le signal par une constante $k'$ tel que si on note $k$ le gain de la dynamo tachymétrique \textit{(par rapport à une vitesse en rad/s)}, on ait: $$k'\cdot\dfrac{1800\cdot V_{DD}\cdot t_0}{2\pi}=k \Leftrightarrow k'= k\cdot\dfrac{2\pi}{1800\cdot V_{DD}\cdot t_0} = \Big(\dfrac{1}{2}\cdot \dfrac{6}{1000}\cdot\dfrac{30}{\pi}\Big)\cdot\dfrac{2\pi}{1800\cdot V_{DD}\cdot t_0}$$
          Il y a une contrainte à respecter avec cette méthode, c'est le choix de $t_0$. En effet, ce dernier doit être plus petit que la période du codeur pour être certain qu'aucun front montant ne soit raté et donc ne fausse le résultat.\\ \\
          \newpage
          Dans la pratique, le monostable se construirait avec un \textbf{NE555} monté en monostable comme dans le schéma suivant:
          \begin{figure}[H]
              \centering
              \input{CircuitTikz/ne555}
              \caption{NE555 monté en astable}
          \end{figure}

          On aurait alors: $$t_0=\ln(3)\cdot R\cdot C$$
    \item \textbf{Méthode 2: Circuit dérivateur}\\
          L'autre méthode exploite le signal de sortie d'un circuit dérivateur. Le schéma de ce circuit est présenté ci-dessous:

          \begin{figure}[H]
              \centering
              \input{CircuitTikz/derivateur}
              \caption{Circuit dérivateur}
          \end{figure}

          La diode permet de ne garder qu'uniquement les alternances positives. \\ \\
          En réponse à l’échelon de tension $V_{DD}$ imposé par le codeur et en notant $\tau=RC$, on sait qu'on a en sortie un signal régit par l'équation suivante:
          $$v_s(t)=V_{DD}\cdot \exp\Big({-\frac{t}{\tau}}\Big)$$
          On en déduit la valeur moyenne de ce signal:
          $$<v_s(t)>=\frac{1}{T}\int_0^TV_{DD}\cdot\exp\Big({-\frac{t}{\tau}}\Big)~dt=\frac{\tau}{T}\cdot V_{DD}$$
          On constate qu'on obtient le même résultat qu'avec la méthode 1, le gain à appliquer suit donc la même formule. \\ \\
          La contrainte à respecter pour $\tau$ est qu'il doit être négligeable devant la période du codeur. En effet, il faut que le signal de sortie du dérivateur ait le temps d'atteindre son régime permanent avant l’échelon suivant. La justification est la même que pour la méthode 1 à la différence qu'ici $\tau$ ne doit pas seulement être inférieur à $T$ mais très inférieur.
\end{itemize}
Avec ces deux méthodes, nous obtiendrons des signaux contenant des harmoniques en plus de la valeur moyenne qui contient l'information utile : cela pourrait venir perturber le fonctionnement du système. De ce fait, pour obtenir un signal moins oscillant autour de la valeur moyenne, nous procéderons à un filtrage passe-bas. Il y a deux contraintes à respecter sur la fréquence de coupure:
\begin{itemize}
    \item Elle doit être assez basse pour atténuer suffisamment les harmoniques.
    \item Elle ne doit pas être trop basse afin ne pas introduire un pôle non-négligeable qui pourrait venir ralentir la réponse de notre système.
\end{itemize}
Après de premières estimations en tenant compte de la vitesse nominale du moteur et du temps réponse souhaité pour le système, nous avons procédé à des tests empiriques par simulation sur PSIM. Nous sommes arrivés à une valeur concluante de fréquence de coupure d'environ 1 kHz.
\\
\\
Finalement, compte-tenu de l'incertitude sur les composants que nous utiliserons, il est fort probable que les gains (\textit{cf. méthodes 1 $\&$ 2}) calculés et mise en œuvre ne soit pas exactement les bons. C'est pour cela que nous mettrons en œuvre un gain réglable que nous ajusterons lors des tests pour obtenir une réponse la plus proche possible de nos attentes. Il est important de d'abord filtrer puis amplifier pour éviter de saturer les AOPs.
\\ \\
Nous avons dans un premier temps simulé la méthode 1 en tenant compte de toute les remarques précédentes sur PSIM. Le schéma est présenté sur la figure ci-dessous:
\begin{figure}[H]
    \centering
    \includegraphics[width=0.42\linewidth]{Images/Modelisation/PSIM/NE555.jpg}
    \caption{Schéma de simulation de la méthode 1 sous PSIM}
    \label{fig:53}
\end{figure}
\textit{Il est important de noter que lorsque nous avons réalisé ces simulations, nous n'avions pas encore tous les éléments concernant le système (tension de sortie du capteur à l'état haut...).\\ De plus, ce n'est pas la méthode finale que nous avons décidé d'adopter, et le but de ces simulations était de nous assurer du fonctionnement de la méthode. Ainsi, certains éléments pourraient manquer de cohérence, mais cela ne retire pas les conclusions quant à son bon fonctionnement. Si nous avions choisi cette méthode, nous aurions, comme nous le verrons pour l'autre solution, approfondi la simulation avec les composants réels.} \\ \\
Le gain se situe dans le même bloc que le filtre. Sur la figure suivante, on retrouve la réponse du système asservie avec le retour vitesse provenant du codeur. En rouge, on retrouve la réponse en sortie du circuit de mise en forme et en vert la réponse en sortie du capteur tachymétrique.
\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{Images/Modelisation/PSIM/NE55_Ass.png}
    \caption{Résultat méthode 1 }
    \label{fig:54}
\end{figure}
\textit{On a en abscisse le temps en seconde et en ordonnée la tension image de la vitesse en volt.} \\ \\
On obtient bien les caractéristiques attendues et on conclut que la méthode fonctionne.
\\

Nous nous sommes assurés de la même façon avec succès du bon fonctionnement de la deuxième méthode. Au vu de sa simplicité, nous avons opté pour cette solution. Avant d'évoquer sa mise en œuvre, un dernier élément est à préciser. Le capteur tachymétrique renvoie non seulement une information sur la vitesse de rotation, mais aussi sur le sens grâce au signe de la valeur retournée. Cela permet d'asservir le moteur dans les deux sens. Ce n'est pour l'instant pas le cas avec notre circuit du codeur. Pour corriger cela, nous utiliserons un multiplexeur analogique dont le schéma est présenté ci-dessous:
\begin{figure}[H]
    \centering
    \input{CircuitTikz/multiplexeur}
    \caption{Multiplexeur analogique}
\end{figure}
Ce montage permutera entre le signal inversé ou non-inversé en fonction du signal appliqué à la base du MOSFET. Ce dernier proviendra du circuit \textbf{indicateur de sens de rotation} que nous verrons plus tard. \\
\newpage
Nous pouvons maintenant passer à la mise en œuvre complète du circuit de mise en forme.
\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{Images/Modelisation/PSIM/Circuit_codeur_pinal.png}
    \caption{Schéma de simulation de la méthode 2 sous PSIM}
    \label{fig:56}
\end{figure}
On note l'ajout d'un suiveur avant le circuit dérivateur pour ne pas que les étages suivants n'ait d'influence sur la sortie du comparateur. Le filtre sera simplement un circuit RC. Nous exposerons les résultats de simulation du système complet dans le chapitre suivant.

\subsection{Limiteur de courant}
Afin de respecter le cahier des charges et limiter le courant d'induit à $1,1\cdot I_{nom}=5$ A, nous utiliserons un circuit limiteur de courant.
Pour réaliser cela, nous avons pu mettre en place le circuit suivant à l'aide d'un AOP :

\begin{figure}[H]
    \centering
    \input{CircuitTikz/limiteur_courant}
    \caption{Circuit limiteur de courant}
\end{figure}
On réglera $R'$ pour obtenir la tension de seuil désirée.
\subsection{Limiteur de la tension de commande}
Ce limiteur est intégré au hacheur et permet de ne pas dépasser la tension de commande maximale.
\subsection{Indicateur de sens de rotation}
Pour obtenir l'information sur le sens du rotation du moteur, nous allons utiliser le circuit suivant:
\begin{figure}[H]
    \centering
    \input{CircuitTikz/bascule_d}
    \caption{Circuit indicateur de sens de rotation}
\end{figure}
Où \textbf{A} et \textbf{B} sont les signaux issus du codeur après passage dans les comparateurs de remise en forme. Avec ce circuit, en fonction du sens de rotation, $Q$ ou $\overline{Q}$ sera à l'état haut et éclairera une LED d'indication. En effet, dans un sens le signal A sera en avance sur B et en retard dans l'autre. Ainsi, au front montant de B, on récupère l'information sur le sens de rotation grâce à la valeur de A. On utilise aussi la sortie $\overline{Q}$ pour piloter le transistor du multiplexeur analogique.
\subsection{Récapitulatif }

Après avoir détaillé l'ensemble des circuits qui composent notre système, nous récapitulons ici l'ensemble des composants utilisés pour chaque montage et leur valeur réelle. Les composants ont été commandés sur le site marchand de Farnell. Dans notre cas, nous avons choisi d’utiliser principalement des éléments CMS à l’exception des potentiomètres et de la bascule D.


\begin{table}[H]
    \centering
    \small
    \setlength{\tabcolsep}{6pt}

    \begin{tabularx}{\textwidth}{>{\raggedright\arraybackslash}X
            >{\raggedright\arraybackslash}X}
        \toprule
        \textbf{Fonction}                  & \textbf{Composants et valeurs} \\
        \midrule

        Correcteur de vitesse              &
        $R = 43\,\text{k}\Omega$,\;
        $R_1 = 1,2\,\text{k}\Omega$,\;
        $R_2 = 2,7\,\text{k}\Omega$,\;
        $C = 1\,\mu\text{F}$,\;
        AOP : TL084 (×2)                                                    \\

        Correcteur de courant              &
        $R = 1\,\text{k}\Omega$,\;
        $R_1 = 1,1\,\text{k}\Omega$,\;
        $R_2 = 6,8\,\text{k}\Omega$,\;
        $C = 150\,\text{nF}$,\;
        AOP : TL084 (×2)                                                    \\

        Comparateur courant                &
        $R = 1,2\,\text{k}\Omega$ (×4),\;
        AOP : TL084                                                         \\

        Comparateur vitesse                &
        $R = 1,2\,\text{k}\Omega$ (×4),\;
        AOP : TL084                                                         \\

        Limiteur de courant                &
        $R = 1,2\,\text{k}\Omega$ (×4),\;
        $R' = 10\,\text{k}\Omega$ (×2),\;
        AOP : TL084,\;
        Diodes : 1N4148WS (×2)                                              \\

        Indicateur de sens de rotation     &
        Bascule D : CD4013,\;
        LED rouge + LED jaune,\;
        $R = 1\,\text{k}\Omega$ (×2)                                        \\

        Circuit dérivateur                 &
        $R = 1\,\text{k}\Omega$,\;
        $C = 1\,\text{nF}$,\;
        Diode : 1N4148WS,\;
        AOP : TL084                                                         \\

        Filtre RC                          &
        $R = 1,1\,\text{k}\Omega$,\;
        $C = 150\,\text{nF}$                                                \\

        Multiplexeur analogique            &
        $R = 1,1\,\text{k}\Omega$ (×4),\;
        MOSFET : BSS138,\;
        AOP : TL084                                                         \\

        Comparateurs signaux codeur        &
        $R = 1,1\,\text{k}\Omega$ (×2),\;
        Comparateurs : LM2903 (×2)                                          \\

        Amplificateur réglable pour codeur &
        $R' = 10\,\text{k}\Omega$,\;
        AOP : TL084                                                         \\
        Diviseur du signal tachymétrique   & $R=1,2$ k$\Omega$ (x2)         \\
        \bottomrule
    \end{tabularx}

    \caption{Tableau récapitulatif des composants utilisés}
    \label{tab:composants}
\end{table}
Les notations des composants sont les mêmes que sur les circuits détaillés plus haut. La notation $R'$ correspond aux potentiomètres. En pratique, nous avons utilisé des TL084 qui inclut 4 AOPs, la notation $(\times2)$ dans le tableau signifie donc que nous avons utilisé 2 AOPs d'un seul composant TL084 pour le circuit.


\section{Simulation du système réel}
Maintenant que notre système réel est complètement dimensionné, nous pouvons passer à  sa simulation complète sur PSIM avant de passer à sa réalisation effective. Voici le schéma de notre système réel sous PSIM:
\begin{figure}[H]
    \centering
    \includegraphics[width=1.\linewidth]{Images/Modelisation/PSIM/schm_reel_1.png}
    \caption{Schéma de simulation du système réel sous PSIM - Boucle d'asservissement}
    \label{fig:59}
\end{figure}


\begin{figure}[H]
    \centering
    \includegraphics[width=1.\linewidth]{Images/Modelisation/PSIM/schm_reel_2.png}
    \caption{Schéma de simulation du système réel sous PSIM - Partie capteurs}
    \label{fig:60}
\end{figure}
Nous avons simulé grâce à ce schéma le bon fonctionnement du système complet avec \textbf{les deux capteurs} pour des consignes \textbf{positives} et \textbf{négatives}.
\newpage
Voici les résultats, on retrouvera en rouge les courbes théoriques attendues avec les composants blocs "parfaits" intégrés à PSIM et en vert les courbes réelles en sortie des capteurs correspondants:
\begin{figure}[H]
    \centering
    \includegraphics[width=1.\linewidth]{Images/Modelisation/PSIM/tacchy_reel_plus.png}
    \caption{Résultats pour une consigne positive avec le capteur tachymétrique}
    \label{fig:61}
\end{figure}
\begin{figure}[H]
    \centering
    \includegraphics[width=1.\linewidth]{Images/Modelisation/PSIM/tachy_reel_moins.png}
    \caption{Résultats pour une consigne négative avec le capteur tachymétrique}
    \label{fig:62}
\end{figure}
\begin{figure}[H]
    \centering
    \includegraphics[width=1.1\linewidth]{Images/Modelisation/PSIM/Codeur_simu_reel_plus.png}
    \caption{Résultats pour une consigne positive avec le codeur incrémental}
    \label{fig:63}
\end{figure}
\begin{figure}[H]
    \centering
    \includegraphics[width=1.\linewidth]{Images/Modelisation/PSIM/codeur_reel_moins.png}
    \caption{Résultats pour une consigne négative avec le codeur incrémental}
    \label{fig:64}
\end{figure}
\textit{On a en abscisse le temps en seconde et en ordonnée l'image de la vitesse en volt}.\\
\\
On constate une très bonne correspondance entre théorie et système réel simulé ce qui valide donc notre dimensionnement. On peut à présent passer à la création de la carte électronique.
\section{Réalisation pratique}

\subsection{Implémentation dans Proteus}
Maintenant que nous avons définis et dimensionnés nos éléments, nous pouvons commencer à les implémenter dans Proteus.
\\
\\
Premièrement, mettons en place les entrées et sorties des signaux utiles. Nous avons opté, pour ce projet, de séparer les bornes d'entrées de la carte afin d'avoir plus de flexibilité. Ainsi, l'entrée sur la carte se fera via des borniers à 2, 3 ou 4 entrées. La masse de notre circuit de commande sera faite en reliant le "-" de l'alimentation positive et le "+" de l'alimentation négative. Ceci sera fait directement sur l'alimentation. De plus, nous allons placer des condensateurs de découplage sur les alimentations, afin de réduire au maximum le bruit. Ils auront une valeur de 1 µF.
\newpage
On définit donc tout cela sur Proteus comme suit :
\begin{figure}[H]
    \centering
    \includegraphics[width=0.45\linewidth]{Images/photo_pcb/Alims et entrées.png}
    \caption{Entrées de la carte}
    \label{fig:placeholder}
\end{figure}
Il est important de bien rajouter la masse sur les borniers afin d'avoir la même référence de tension sur les capteurs, le hacheur et le circuit de commande.
\\
\\
Ensuite, nous allons réaliser la boucle principale de notre asservissement, c'est à dire le comparateur suivi du correcteur de vitesse, puis du limiteur de courant, du second comparateur et du correcteur de courant.
\\
\\
Pour ce faire, nous avons décidé d'utiliser des TL084, car ces boîtiers comprennent 4 AOP, ce qui permettra par la suite de simplifier les routages. Avec un premier TL084, on peut donc réaliser la chaîne suivante :

\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{Images/photo_pcb/Première boucle proteus.png}
    \caption{Première chaîne}
    \label{fig:placeholder}
\end{figure}
\newpage
On y retrouve, comme sur le schéma bloc, de gauche à droite :
\begin{itemize}
    \item Un soustracteur, la valeur des résistances importent peu du moment qu'elles sont toutes égales. Il s'agit du comparateur de vitesse.
    \item Le correcteur PI de la vitesse, composé d'abord de la partie intégrale suivie de la partie proportionnelle.
    \item Un limiteur de courant composé de diodes et de potentiomètres.
\end{itemize}

Avec le second TLO84, on termine la chaîne principale de l'asservissement, comme suit :

\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{Images/photo_pcb/Deuxième partie de la chaine.png}
    \caption{Seconde partie de la chaîne principale}
    \label{fig:placeholder}
\end{figure}
On retrouve à nouveau de gauche à droite, similairement au schéma bloc :


\begin{itemize}
    \item Un  nouveau soustracteur, qui joue le rôle de comparateur de courant.
    \item Le correcteur PI du courant, composé d'abord de la partie intégrale suivie de la partie proportionnelle.
\end{itemize}

Au final, on se retrouve avec le montage complet suivant :

\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{Images/photo_pcb/chaine complete.png}
    \caption{Chaîne complète d'asservissement}
    \label{fig:placeholder}
\end{figure}

En plus de la chaîne d'asservissement principale, nous allons avoir besoin de certains circuits auxiliaires, notamment pour l'acquisition des signaux d'entrée.
\\
\\
Comme nous l'avons expliqué en première partie, les signaux issus de codeur incrémental doivent d'abord être comparés à une tension de référence 7,5 V, puis dérivés et enfin filtrés. La simulation PSIM a démontré l'importance du filtrage dans cette application.
\\
\\
Sur Proteus, cela équivaut aux schémas suivants :
\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\linewidth]{Images/photo_pcb/Comparateur.png}
    \caption{Comparateur de tension}
    \label{fig:placeholder}
\end{figure}
Pour le comparateur, nous avons opté pour le LM2903, car ce dernier comporte deux comparateurs dans un unique boîtier, simplifiant à nouveau le routage par la suite.
\\
Nous avons également rajouté des résistances de pull-up à la sortie du comparateur car les sorties du codeur sont à collecteur ouvert. Nous nous sommes rendus compte par la suite que nous aurions dû les mettre en amont du comparateur et non en aval, mais nous avons su résoudre ce problème.
\\
\\
Pour réaliser la tension de référence 7.5 V, nous avons simplement implémenter un circuit pont diviseur de tension avec un suiveur. Sous Proteus, cela donne :

\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{Images/photo_pcb/PdT.png}
    \caption{Pont diviseur de tension par deux}
    \label{fig:placeholder}
\end{figure}

Il s'agit d'un montage très basique mais fonctionnel. L'alimentation n'étant pas forcément stable, nous aurions pu également rajouter des condensateurs tampons pour palier aux éventuelles chutes de tension, ou directement utiliser un circuit régulateur de tension comme le LM7905. Cependant, nous avons jugé que pour cette application, un pont diviseur suffirait.
\\
\\
Ensuite, nous avons besoin d'un dérivateur suivi immédiatement d'un filtre passe-bas puis d'un gain variable. Ce schéma est le suivant :

\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{Images/photo_pcb/Circuit codeur.png}
    \caption{Dérivateur + filtre passe bas + Gain variable}
    \label{fig:placeholder}
\end{figure}

Parallèlement à cela, on réalise, à l'aide d'une bascule D, le circuit permettant de déterminer le sens de rotation du codeur.

\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{Images/photo_pcb/Bascule.png}
    \caption{Circuit à bascule D}
    \label{fig:placeholder}
\end{figure}
Nous avons rajouté des LEDs en tant qu'indicateur visuel du sens de rotation.
\newpage
Enfin, pour terminer l'acquisition du signal provenant du codeur, nous devons multiplexer le signal en sortie du filtre. Pour ce faire, on réalise le montage suivant :
\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\linewidth]{Images/photo_pcb/Multiplexeur.png}
    \caption{Circuit de Multiplexage à AOP}
    \label{fig:placeholder}
\end{figure}
Où le signal de grille du MOS est le signal $\bar{Q}$ de la bascule et celui en entrée de $R_{24}$ et $ R_{26}$ est le signal en sortie du filtre passe bas.
\\
\\
Ainsi, la chaîne complète d'acquisition du signal du codeur incrémental est donnée ci-dessous :
\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{Images/photo_pcb/Chaine complete codeur.png}
    \caption{Chaîne complète d'acquisition du codeur}
    \label{fig:placeholder}
\end{figure}
\newpage
Enfin, pour finaliser la commande, il ne nous reste plus qu'à implémenter un simple circuit diviseur de tension par deux pour l'acquisition du signal de la dynamo tachymétrique. Ceci donne :
\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\linewidth]{Images/photo_pcb/tachy div.png}
    \caption{Diviseur de tension pour le signal issu  de la dynamo tachymétrique.}
    \label{fig:placeholder}
\end{figure}

Avec ceci nous concluons la partie schématique de l'implémentation sur Proteus. Après avoir vérifié les liens entre toutes les sources et les circuits, nous pouvons passer au routage de la carte.


\subsection{Création du PCB}
Nous pouvons maintenant nous concentrer sur la réalisation du PCB. Cette partie du projet est importante car c'est avec elle que le projet s'ancre dans le réel. Nous devrons maintenant nous projeter afin de designer une carte optimisée et physiquement réalisable.
\\
\\
Pour les composants, nous avons choisi de partir sur une carte quasi entièrement composée de composants CMS. Cela nous permettra d'une part de simplifier les soudures car il suffira de placer les composants et de les mettre au four, mais également de gagner de la place car les composants CMS sont très petits.
Des inconvénients existent néanmoins : les composants CMS seront plus compliqués à ressouder par la suite, et nous ne pourrons pas utiliser leurs broches comme des vias.
\\
\\
Avant de commencer le routage, nous avons dû commander les composants en portant une grande attention à leurs dimensions. En effet, il fallait que leur taille ne soit pas trop petite afin de pouvoir les manipuler.
\\
Ensuite, une fois les composants choisis, nous avons pu en extraire les packages. La plupart du temps, les boîtiers des composants ne correspondaient pas à ce que nous avions sur Proteus, il a donc fallu réaliser les packages manuellement en s'aidant des datasheets des composants. En plus de cela, il fallait porter soin à l'ordre des broches des composants plus complexes comme le comparateur ou le transistor pour assurer de leur bon fonctionnement.

\subsubsection{Règles de conception}
Maintenant, parlons des règles de design que nous avons respecté pour s'assurer une carte réussie.
\\
Tout d'abord, nous avons appris lors des projets précédents qu'il est primordial de laisser un espace entre chaque piste pour éviter les courts-circuits. Dans l'onglet "règle de conception", nous avons alors stipulé un écart minimum de 25th entre toutes les zones cuivrées; pistes, vias, broches, plan de masse...
\\
Des exceptions à cette règle ont néanmoins du être faites au niveau des broches du comparateur en raison de sa très petite taille.
\\
\\
La prochaine étape a consisté à rajouter un plan de masse sur chaque face du PCB. Cela présente plusieurs avantages. D'une part, cela accorde un accès facile à la masse sur toute une face, simplifiant grandement les routages. D'autre part, cela évite de retirer inutilement une grande quantité de cuivre et permet alors de gagner du temps et d'économiser de la matière lors de la conception physique de la carte.
\\
\\
Au niveau des packages de composants, servant à modéliser ces derniers sur le logiciel, nous avons, pour ceux réalisés par nous-mêmes, volontairement agrandi les pastilles cuivrées afin d'avoir une marge de manœuvre lors des soudures. Cela permet également une meilleure répartition de l'étain sur le cuivre.
\\
\\
Enfin, nous avons placé tous les composants CMS sur une face, et tous les composants traversants sur l'autre. Ainsi, nous savons que toutes les soudures se feront sur la même face (à l'exception des vias et de certaines broches des TL084 qui servent de vias).
\\
\\
La carte étant un circuit de commande, nous n'avions pas de contraintes de puissances ou de perturbations électromagnétiques majeures, la taille des pistes importait donc peu.
\\
\\
Certains de nos composants ne seront pas directement placés sur la carte mais reliés par des fils, comme les LEDs et le switch. Pour les réaliser, nous avons donc pris des packages ayant le même nombre de broches sans s'attarder sur les dimensions.


\subsubsection{Modélisations finies}
Maintenant que nous avons les règles de conception en tête, nous pouvons commencer le design du PCB.
\\

Le PCB final est donné ci-dessous :

\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{Images/photo_pcb/PCB_final.png}
    \caption{Design du PCB avant impression}
    \label{fig:placeholder}
\end{figure}

Remarquons que les règles de conception ont bien été respectées avec un écart précis entre chaque piste. Les seules exceptions aux règles se situent au niveau du comparateur et des potentiomètres, car les broches des composants elles-mêmes ne les respectent pas.
\\
\\
Concernant les TL084, nous avions d'abord opté pour des composants traversants, afin de pouvoir utiliser les broches de ces derniers comme des vias et ainsi limiter les perçages sur la carte. Cependant, au moment de la commande, il ne restait plus que leur version CMS sur Farnell. Ainsi, nous avons dû "transformer" ces composants CMS en composants traversants.
\\
Lorsque l'on utilise des puces CMS comme nous l'avons fait pour les AOP, il est d'usage pour des projets de ce type de réaliser une carte de support à CMS pour simplifier la mise en place de ces derniers. C'est ce que nous avons fait :
\\
\begin{figure}[H]
    \centering
    \begin{minipage}{0.48\textwidth}
        \centering
        \includegraphics[width=\linewidth]{Images/photo_pcb/CMS_prot.png}
        \caption{Modélisation du PCB accueillant le composant CMS}
        \label{fig:face-traversants}
    \end{minipage}
    \hfill
    \begin{minipage}{0.48\textwidth}
        \centering
        \includegraphics[width=\linewidth]{Images/photo_pcb/CMS_réel.jpg}
        \caption{PCB réel}
        \label{fig:face-cms}
    \end{minipage}
\end{figure}
La puce CMS étant trop large pour le support traversant, il a fallu la décaler et la placer à l'envers pour éviter un routage trop complexe.
\newpage
De même, pour le connecteur VGA, nous avons réalisé une carte pour simplifier les connexions entre la carte et ce dernier :
\begin{figure}[H]
    \centering
    \begin{minipage}{0.48\textwidth}
        \centering
        \includegraphics[width=\linewidth]{Images/photo_pcb/VGA_Prot.png}
        \caption{Modélisation du PCB accueillant le connecteur VGA}
        \label{fig:face-traversants}
    \end{minipage}
    \hfill
    \begin{minipage}{0.48\textwidth}
        \centering
        \includegraphics[width=\linewidth]{Images/photo_pcb/VGA_réel.jpg}
        \caption{PCB assurant le lien avec le connecteur VGA}
        \label{fig:face-cms}
    \end{minipage}
\end{figure}
Nous nous sommes aidés du schéma suivant, montrant comment router les différentes entrées sur les bons pins du connecteur :
\\
\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\linewidth]{Images/photo_pcb/routage_vga.png}
    \caption{Schéma de câblage du connecteur VGA}
    \label{fig:placeholder}
\end{figure}

A noter que le codeur incrémental est alimenté en 15 V dans notre cas.
\newpage
\subsection{Soudures et Tests de la carte}
Une fois la carte physique récupérée, nous avons dans un premier temps vérifié qu'aucun court circuit n'était présent. Nous n'en avons trouvé que deux, ce qui prouve que nous avons bien fait de mettre un écart minimal entre les pistes. Le cas échéant, il a suffit de gratter la piste avec un cutter pour résoudre le problème.
\\
\\
Ensuite, nous avons pu commencer les soudures.
\\
\\
Il fallait forcément commencer par les composants CMS car les traversants, munis de pièces en plastique, ne peuvent pas supporter les températures du four.
Nous avons alors méthodiquement placé nos résistances, nos condensateurs, diodes, transistor et comparateur. Nous placions sur la carte d'abord toutes les résistances d'une certaine valeur avant de passer aux suivantes pour ne pas nous perdre dans les petits CMS. De plus, il fallait être vigilant au sens des diodes. Un trait fin sur le boîter permet d'indiquer la cathode.
\\
\\
Ici, nous avons eu peu de problèmes. Seules deux résistances ont été mal soudées et donc ne faisaient pas le lien. Elles ont donc été ressoudées au fer et le problème était résolu.

Nous avons par la suite soudé les vias. Ceux-ci sont au nombre de 18 et ont été faits avec du fil issu de câbles multibrins.
\\
\\
Enfin, nous sommes passés aux composants traversants. La seule difficulté que nous avons rencontrée fut au niveau des supports des AOPs. En effet, nous ne disposions que d'un nouveau modèle dont les broches métalliques ne sont pas accessibles par le dessus. Ceci nous posa problème compte tenu que certaines soudures des pattes d'AOP devaient être faites des deux côtés de la carte.

Nous nous en sommes sortis en récupérant des supports sur d'anciens projets.
\\
\\
Voici à quoi ressemble la carte terminée :
\begin{figure}[H]
    \centering

    \begin{minipage}{0.48\textwidth}
        \centering
        \includegraphics[width=\linewidth]{Images/photo_pcb/face cms.png}
        \caption{Face CMS}
        \label{fig:face-cms}
    \end{minipage}
    \hfill
    \begin{minipage}{0.48\textwidth}
        \centering
        \includegraphics[width=\linewidth]{Images/photo_pcb/face traversants.png}
        \caption{Face traversants}
        \label{fig:face-traversants}
    \end{minipage}

\end{figure}

Les PCB servant de support à la puce CMS vus précédemment se placent sur 3 des 4 supports. \\
Trois fils sont également reliés à l'interrupteur pour changer de capteur de vitesse.
\subsection{Tests préliminaires}
Nous arrivons vers la fin de notre projet et nous devons maintenant réaliser certains tests préliminaires pour nous assurer du bon fonctionnement de la carte.
\\
\\
Nous allons tout d'abord nous assurer du bon fonctionnement du circuit d'asservissement par retour tachymétrique, puis nous vérifierons l'acquisition du signal issu du codeur incrémental.
\\
\\
Pour ce faire, nous avons tout d'abord simulé sur PSIM ce qu'il se passerait si nous court circuitions les condensateurs des correcteurs intégrales. Ainsi, nous avions un ordre d'idée de ce à quoi nous devions nous attendre. Voici la simulation PSIM:
\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{Images/Modelisation/PSIM/Test_preli.jpg}
    \caption{Schéma de test préliminaire sur PSIM}
    \label{fig:placeholder}
\end{figure}
Ensuite, nous avons réellement court-circuité ces condensateurs à l'aide d'une patte de résistance qui reliait leur borne. En plaçant en entrée un signal constant, nous avons pu mesurer la tension sur certains points importants et comparer à la simulation.
\\
Si les valeurs étaient cohérentes avec PSIM, cela signifiait que notre carte fonctionnait correctement et que nous pouvions donc passer aux tests finaux.
\\
\\
Après avoir vérifié l'asservissement avec la dynamo tachymétrique sur le banc d'essai, nous avons pu nous assurer que l'acquisition du signal codeur ainsi que son traitement se passait comme convenu.
\\
Pour cela, il a d'abord fallu tester la correspondance des entrées du câble VGA avec le connecteur branché sur le codeur selon le schéma de câblage.
\\
Pour cela, nous devions vérifier au niveau de l'interrupteur que le signal issu du codeur était similaire à celui issu de la dynamo tachymétrique.
\\
Ici, contrairement à la dynamo., nous avons rencontré plusieurs problèmes avant de pouvoir asservir correctement. Tout d'abord, le codeur incrémental n'était pas alimenté par le +15V. Nous nous sommes rendus compte qu'il s'agissait d'une soudure mal faite au niveau du bornier du VGA, il nous a alors suffi de la refaire.
\\
Ensuite, nous avons remarqué que les signaux issus du codeur au niveau du comparateur n'avaient pas la forme en créneau attendu. Ce problème venait de l'absence de résistances de pull-up en sortie du codeur. Nous les avons alors rajoutées ce qui a réglé le problème.
\\
Enfin, une soudure mal faite au niveau de la bascule D empêchait l'acquisition du signal B du codeur. Nous l'avons refaite et avons finalement pu observer un signal similaire à celui issu de la dynamo. au niveau de l'interrupteur.
\\
\\
Maintenant que nous avons mis en accord les résultats théoriques de simulation et pratiques, nous pouvons passer aux vrais tests sur le banc d'essai.
\newpage
\subsection{Test finaux}

Pour les premiers tests sur le banc, n'ayant pas encore de boite et les bornes BNC n'étant donc pas soudées, nous nous sommes servis de câbles ayant à leur extrémité un embout coaxial et de l'autre des fils.
\\
Une fois la boite réalisée, il a été bien plus simple de connecter le système au différents éléments extérieurs grâce aux bornes fixées. Cependant, étant donné le PCB bloqué et certains composants difficiles d'accès, il était nécessaire de démonter ce dernier pour effectuer des tests.
\\
Parmi les éléments extérieurs, on compte le hacheur fournissant un signal commandant le moteur ainsi que le retour du courant du moteur via le hacheur, le GBF servant à ajuster la vitesse de fonctionnement et enfin la dynamo tachymétrique et le codeur incrémental pouvant être utilisés alternativement par le changement de l'état de l’interrupteur. La partie alimentation se compose de deux alimentations symétriques, l'une fournissant 15 V, l'autre -15 V et les deux reliées à une masse commune.
\\
Avant de se concentrer sur le bon fonctionnement du système, nous avons réglé les potentiomètres limitant le courant pour que le signal ne dépasse pas les 5 V. On retrouve ici le bon fonctionnement du limitateur:
\begin{figure}[H]
    \centering    \includegraphics[width=1\linewidth]{Images/oscillo/courantcodeur.png}
    \caption{Bon fonctionnement du limitateur de courant}
    \label{fig:placeholder}
\end{figure}
Puis, nous avons démarré le système pour tester l'asservissement à l'aide de la dynamo-tachymétrique et y vérifier que nous respections les exigences du cahier des charges.
\newpage
On observe sur la capture d'écran ci-dessous que nous respectons le temps de réponse 10 fois plus rapide qu'en boucle ouverte ainsi qu'un dépassement inférieur à 20 \%.
\begin{figure}[H]
    \centering    \includegraphics[width=0.9\linewidth]{Images/oscillo/depa vitesse.png}
    \caption{Dépassement réel avec la dynamo-tachymétrique}
    \label{fig:placeholder}
\end{figure}
\begin{figure}[H]
    \centering    \includegraphics[width=0.9\linewidth]{Images/oscillo/vitesse tr5.png}
    \caption{Temps de réponse réel avec la dynamo-tachymétrique}
    \label{fig:placeholder}
\end{figure}
\newpage
Après le succès de ce test, nous nous sommes penchés sur les essais avec le codeur incrémental. Voici ce que nous obtenions :
\begin{figure}[H]
    \centering    \includegraphics[width=1\linewidth]{Images/oscillo/vitesse_codeur_avant_correction.png}
    \caption{Première réponse réelle avec le codeur incrémental}
    \label{fig:placeholder}
\end{figure}

A ce moment, nous avions une réponse cohérente au niveau de la forme mais pas parfaitement en accord avec la théorie au niveau du gain. En effet, une erreur statique subsistait et le potentiomètre de gain ne suffisait pas à l'annuler.
\\
Le problème se situait en réalité au niveau du dérivateur. Nous avons observé avec une sonde de tension que le signal en sortie du dérivateur ne convenait pas, ce qui est la conséquence direct d'une constante de temps trop grande, elle-même issue d'un condensateur de mauvaise valeur.
\\
Nous avons mesuré le condensateur du dérivateur à l'aide d'un RLC-mètre, et avons remarqué qu'il avait une valeur de 10 nF contre 1 nF calculé. Nous avons donc changé ce condensateur pour un de 1 nF, puis repris les tests.
\\
\\
Cette fois-ci, lorsque nous mettions le système sous tension, on remarquait un gain beaucoup trop important, alors qu'auparavant il était trop petit, ce qui était bon signe compte-tenu de notre situation.
\\
Nous avons donc graduellement diminué le gain du codeur avec le potentiomètre prévu à cet effet jusqu'à avoir une erreur statique nulle.
\newpage
Les résultats de ces tests sont donnés ci-dessous:
\begin{figure}[H]
    \centering    \includegraphics[width=1\linewidth]{Images/oscillo/codeur_corrige.png}
    \caption{Première réponse réelle avec le codeur incrémental}
    \label{fig:placeholder}
\end{figure}
On obtient maintenant des résultats plus que satisfaisant répondant à nos exigences.\\

Par la suite, nous avons voulu comparer ces résultats avec nos simulations PSIM abordées précédemment. Nous avons donc superposé les courbes réelles et théoriques. En rouge, nous retrouvons la courbe réelle et en bleu celle simulée sur PSIM:
\begin{figure}[H]
    \centering    \includegraphics[width=0.8\linewidth]{Images/Modelisation/MATLAB/Tachy.png}
    \caption{Comparaison courbes réelle et théorique - dynamo-tachymétrique}
    \label{fig:placeholder}
\end{figure}
\begin{figure}[H]
    \centering    \includegraphics[width=1\linewidth]{Images/Modelisation/MATLAB/Codeur_corrige.png}
    \caption{Comparaison courbes réelle et théorique - codeur incrémental}
    \label{fig:placeholder}
\end{figure}
\textit{On a en abscisse le temps en seconde et en ordonnée l'image de la vitesse en volt}.\\ \\
On constate de très bonnes correspondances entre ces courbes. Cela valide le fonctionnement correct de notre système complet.
\vspace{2cm}
\subsection{Montage final}
\subsubsection{Réalisation de la boite}

Pour la réalisation de la boite, nous avons opté pour l'impression 3D pour sa polyvalence et sa flexibilité.
\\
Le boîtier n'a pas que pour objectif d'apporter un aspect esthétique et sécurisé au projet. Il assure également la stabilité des soudures et la fixations des éléments entre les bornes du PCB et les prises à l'extérieur de la boîte. En effet, chacun des éléments a une place adaptée à son mode de fixation et un espace suffisant pour éviter tout faux contact et courts-circuits. Ensuite, les inscriptions sur l'extérieur de la boite indiquent quel signal ou alimentation doit être appliquée pour chaque borne extérieure, ainsi que la position de l'interrupteur et le sens rotation.
\newpage
Un premier prototype a été réalisé pour ajuster les tolérances des trous et fixations des éléments.
\\
Le logiciel utilisé pour la modélisation est FreeCAD. L'impression a été réalisée sur une imprimante FDM avec du filament PLA.
\\
\begin{figure}[H]
    \centering

    \begin{minipage}{0.48\textwidth}
        \centering
        \includegraphics[width=\linewidth]{Images/photo_pcb/boite_modelisation2.png}
        \caption{Modélisation 3D du boîtier sur FreeCad}
        \label{fig:face-cms}
    \end{minipage}
    \hfill
    \begin{minipage}{0.48\textwidth}
        \centering
        \includegraphics[width=\linewidth]{Images/photo_pcb/boite_réelle.jpg}
        \caption{Boitier réel}
        \label{fig:face-traversants}
    \end{minipage}

\end{figure}
\vspace{2cm}
\subsubsection{Intégration dans la boite}
Le PCB principal vient se loger dans la boite et est fixé par des vis via des trous disponibles aux quatre coins de celui-ci. De même pour le PCB du connecteur VGA. Avant de fixer les fiches BNC, on soude un fil à la bague servant à relier la masse au câble se logeant dans la borne et un autre fil dans le pin de contact avant de les visser sur les faces extérieures de la boîte, puis on les sécurise à l'aide d'une clef de serrage. Pour les fiches bananes, on utilise des cosses que l'on fixe à des câbles pour faciliter leur contact, ces dernières sont ensuite fixées de la même manière que les fiches BNC. De même pour l'interrupteur qui vient se loger à l'emplacement entre les inscriptions "Codeur" et "Tachy" indiquant quel mode de fonctionnement est sélectionné.
\newpage
Une fois le PCB fixé à la boîte, on peut raccorder les fiches bananes et BNC sur les borniers, eux-mêmes directement liés aux deux PCB grâce aux câbles reliés aux fiches déjà en place. Enfin, on peut glisser les LEDs dans les trous prévus à cet effet dans le couvercle. Le couvercle peut alors être vissé à la boîte pour la fermer.
\\

\begin{figure}[H]
    \centering

    \begin{minipage}{0.48\textwidth}
        \centering
        \includegraphics[width=\linewidth]{Images/photo_pcb/Intégration du pcb.jpg}
        \caption{PCB intégré à la boite vue du haut}
        \label{fig:face-cms}
    \end{minipage}
    \hfill
    \begin{minipage}{0.48\textwidth}
        \centering
        \includegraphics[width=\linewidth]{Images/photo_pcb/pcb dans boite exterieur.jpg}
        \caption{PCB intégré à la boite vue de l'extérieur}
        \label{fig:face-traversants}
    \end{minipage}

\end{figure}
\newpage
\section{Gestion de projet}
Durant ce projet, nous avons suivi un déroulé assez classique dans notre gestion de projet, composée des étapes suivantes :
\begin{itemize}
    \item Étude du cahier des charges
    \item Étude théorique du sujet
    \item Modélisation numérique sur logiciel
    \item Sélection des composants réels
    \item Réalisation physique du projet
    \item Tests et mesures du produit final
\end{itemize}
Naturellement, les tâches ont été réparties et
certains éléments ont apporté de la nouveauté par rapport aux projets que nous avions réalisé précédemment. Notamment, nous n'avions jamais travaillé en groupe de plus de 2 pour un projet nécessitant ce niveau d'implication. Le fait d'être 4 à travailler sur le projet nous a demandé un effort supplémentaire dans la séparation des tâches. La commande des composants a été également plus conséquente et a demandé de l'optimisation pour ne pas dépasser le budget de 25 € imposé par le cahier des charges notamment en faisant une commande commune entre groupes.
\\
\\

\section{Conclusion}

Pour conclure, ce projet nous aura apporté de l'expérience dans la mobilisation de notions d'automatique, principalement par la conception de boucles d'asservissement et la manipulation de fonctions de transfert. L'électrotechnique était également au centre du projet, à travers la modélisation d'un moteur et de l'utilisation de capteurs puis finalement, l'électronique de puissance, par la modélisation d'un hacheur. Également, l'utilisation approfondie de logiciels pour des applications plus conséquentes a développé nos compétences et nous a encouragé à l'utilisation de ces outils. Finalement, nous avons eu l'occasion de développer nos compétences en terme de réalisation pratique par la conception et la soudure d'un PCB.
\\
Ce projet aura été formateur dans l’apprentissage de la gestion de projet détaillée plus haut, il s'agit d'un bagage qui nous servira lors des prochains projet à réaliser dans notre cursus et dans notre métier d'ingénieur.\\
Dans l’ensemble, il aura été une totale réussite tant dans le respect du cahier des charges que dans la réalisation. Nous tenons à remercier M. Flieller pour son accompagnement tout au long du projet.

